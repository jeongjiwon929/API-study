4-1-가. WM_CHAR 메시지
도스(콘솔) 환경에서는 명시적으로 입력을 받는 함수들이 따로 있다. getch, gets, scanf 등의 함수들은 사용자로부터 입력을 요구하는데 입력이 완료될 때까지 절대로 리턴하지 않으며
따라서 이 함수가 리턴하기 전까지 프로그램의 실행은 잠시 중단된다. 싱글 태스킹 환경에서는 혼자만 실행되므로 입력을 받기 전에 시스템 전체를 완전히 블록해도 아무 문제가 없다.
그러나 윈도우즈 환경에서는 이런 명시적인 입력 함수가 존재하지 않으며 반드시 메시지를 받아야 한다. 왜냐하면 여러 개의 프로그램이 동시에 실행되는 멀티 태스킹 환경이며
사용자가 언제 자신에게 관심을 가질지 예측할 수 없기 때문이다.

키보드 메시지에서 str 배열에 문자열을 집어넣기만 하며 문자열을 화면으로 출력하는 일은 WM_PRINT메시지가 자동으로 발생하지 않는다.
그래서 문자가 새로 입력될 때마다 강제로 WM_PAINT 메시지를 발생시켜야 하는데 이 때는 InvalidateRect 함수를 호출하면 된다.
InvalidateRect 호출문을 빼 버리면 입력은 바디만 화면이 제때 갱신되지 않을 것이다. 이 함수 호출문이 있어야 키보드에서 눌러진 키의 문자가 화면으로 즉시 출력된다.
키보드를 누르면서 WM_CHAR 메시지가 발생했을 때의 동작을 잘 생각해 보기 바란다. 입력된 문자가 어떻게 str 배열에 모여 한꺼번에 출력되는가를 상상해 볼 수 있을 것이다.

4-1-나. 무효영역
WM_PAINT 메시지는 윈도우가 다시 그려져야 할 필요가 있을 때마다 호출되는데 다시 그려져야 할 필요가 있다는 말은 무효영역이 있다는 뜻이다.
프로그램 내부에서 윈도우의 모습을 변경시켰을 때는 변경된 부분을 다시 그리도록 강제로 무효화해야 하며 이때 사용되는 함수가 바로 InvalidateRect이다.

BOOL InvalidateRect
- 이 함수는 윈도우의 직업영역을 무효화하며 운영체제로 하여금 WM_PAINT 메시지를 해당 윈도우로 보내도록 한다. 첫 번째 인수는 무효화의 대상이 되는 윈도우, 즉 다시 그려져야 할
윈도우의 핸들이다. 자기 자신을 무효화 할 때는 WndProc으로 전달되는 첫 번째 인수 hWnd를 그대로 써주면 된다. 물론 다른 윈도우를 지정하면 자신이 아닌 다른 윈도우를 무효화할 수도 있다.

- 두 번째 인수 IpRect는 무효화할 사각영역을 지정하되 이 값이 NULL이면 윈도우의 전 영역이 무효화된다. 전 영역을 무효화하면 완전히 다시 그리므로 확실하게 그려지기는 하겠지만
그만큼 그리는 속도는 느려질 것이다. 속도를 최대한 높이려면 변경된 최소한의 영역만을 계산하여 꼭 필요한 부분만 무효화하는 것이 좋다.
